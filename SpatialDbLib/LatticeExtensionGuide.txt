üèóÔ∏è Developer Guide: Extending the Spatial Lattice System

========================================
Architecture Overview
========================================

The spatial lattice uses a type family pattern with generic base classes to support polymorphic node hierarchies. This allows you to create parallel hierarchies (e.g., standard vs. tickable) without code duplication.

Core Hierarchy:

SpatialLattice<TRoot> (generic coordinator)
  ‚îî‚îÄ RootNode<TParent, TBranch, TVenue, TSelf> (generic root with type family)
       ‚îî‚îÄ OctetParentNode (parent node logic)
            ‚îú‚îÄ OctetBranchNode (branch with parent)
            ‚îî‚îÄ LeafNode (abstract leaf)
                 ‚îú‚îÄ VenueLeafNode (leaf with occupants)
                 ‚îî‚îÄ SubLatticeBranchNode<TLattice> (nested lattice)

Key Principles:

1. Type Families Travel Together: Branch, Venue, and Root types must be compatible
2. Shared Depth Tracking: LatticeDepthContext.CurrentDepth is thread-local but shared across ALL generic instantiations
3. Position Stacks: Objects have position stacks; use GetPositionAtDepth(depth) for navigation
4. Factories in Root: Root node knows concrete types via virtual factory methods
5. Interface-Based Polymorphism: Use marker interfaces (e.g., ISubLatticeBranch) for pattern matching across generic types

(Damian's note:)
Claude Sonnet 4.5 is very proud of us finding the bug below, and wrote this general warning to help you avoid the same mistake!
What s/he fails to realize is how, there are like, i dunno, 3 people i've ever known who would care. lol.  Without further adieu...

========================================
‚ö†Ô∏è CRITICAL: ThreadStatic and Generic Types
========================================

NEVER put [ThreadStatic] fields in generic classes! Each closed generic type gets separate static field instances.

WRONG PATTERN:
  public class SpatialLattice<TRoot> {
      [ThreadStatic] private static byte t_depth;  // ‚ùå Separate instance per TRoot!
  }

RIGHT PATTERN:
  internal static class LatticeDepthContext {
      [ThreadStatic] private static byte t_latticeDepth;  // ‚úÖ Shared by all
      public static byte CurrentDepth { get; set; }
  }

This was the source of a multi-day debugging session where assignments appeared to work in the debugger but the value never changed. The debugger was showing the wrong generic instantiation's copy of the field!

========================================
üéØ How to Add New Capabilities (Example: Tickable System)
========================================

Step 1: Define Your Interfaces
--------------------------------------
Create interfaces for the new behavior at each level:

- ITickableSpatialNode: Interface for nodes that can be ticked
- ITickableObject: Interface for objects that participate in ticking
- ITickableChildNode: Combines child behavior with tickable behavior

Step 2: Create Tickable Base Classes
--------------------------------------
Extend the core hierarchy with tickable versions:

- TickableOctetParentNode: Extends OctetParentNode, implements ITickableSpatialNode
- TickableOctetBranchNode: Extends TickableOctetParentNode, implements ITickableChildNode
- TickableVenueLeafNode: Extends VenueLeafNode, implements ITickableChildNode

IMPORTANT: All child node types must implement BOTH:
  - IChildNode<OctetParentNode> for base class compatibility (explicit interface)
  - ITickableChildNode for tickable hierarchy (public implementation)

Step 3: Create Tickable Root Node
--------------------------------------
Define the root that declares the tickable type family:

Create TickableRootNode<TParent, TBranch, TVenue, TSelf> extending TickableOctetParentNode
Must implement IRootNode with the tickable type family
Override CreateBranchNodeWithLeafs to create tickable branches and sublattices
Override CreateNewVenueNode to create tickable venue leafs
Implement ResolveLeafFromOuterLattice for sublattice boundary crossing

Step 4: Create Tickable Lattice Facade
--------------------------------------
Inherit from SpatialLattice<TRoot> to get all standard functionality:

Create TickableSpatialLattice extending SpatialLattice<TickableRootNode>
Override CreateRoot to return your custom TickableRootNode
Add new methods like Tick() that delegate to m_root
No need to reimplement Insert, Remove, etc. - inherit them!

Step 5: Handle Sublattices
--------------------------------------
Create tickable sublattice branch node using SubLatticeBranchNode<TLattice>:

Extend SubLatticeBranchNode<TickableSpatialLattice>
Implement both IChildNode<OctetParentNode> and ITickableChildNode
Pass (byte)(latticeDepth + 1) to sublattice constructor
Store Parent as TickableOctetParentNode with explicit interface implementation for OctetParentNode

========================================
üß™ Testing Your Extension
========================================

Basic Functionality Test:
- Insert tickable object
- Verify insertion into correct leaf type
- Register object for ticks
- Add time delay (Thread.Sleep) to ensure measurable delta
- Call Tick() and verify movement occurred

Sublattice Propagation Test:
- Insert 20+ objects at same location to force sublattice creation
- Call Tick() and verify no errors
- Validates tick propagation through nested lattices

Performance Benchmark:
- Test with increasing object counts (1k, 10k, 50k, 100k, 200k)
- Measure insertion time separately from tick time
- Calculate objects/second throughput
- Verify linear scaling

Expected Performance (Reference):
  1,000 objects:    < 1ms tick time (‚àû objects/sec)
  10,000 objects:   ~10ms tick time (1,000,000 objects/sec)
  50,000 objects:   ~21ms tick time (2,380,000 objects/sec)
  100,000 objects:  ~47ms tick time (2,127,000 objects/sec)
  200,000 objects:  ~84ms tick time (2,380,000 objects/sec)

Linear scaling maintained up to 200k+ objects!

At 10 ticks/second (100ms budget): ~238,000 active moving objects
At 60 ticks/second (16.6ms budget): ~39,600 active moving objects

========================================
‚ö†Ô∏è Common Pitfalls & Solutions
========================================

1. Cast Exceptions on Child Nodes
Problem: "Unable to cast object of type 'TickableVenueLeafNode' to type 'ITickableChildNode'"
Solution: Ensure ALL child node types implement ITickableChildNode:
  - TickableVenueLeafNode ‚úÖ
  - TickableOctetBranchNode ‚úÖ
  - TickableSubLatticeBranchNode ‚úÖ

2. Type Mismatch in CreateBranchNodeWithLeafs
Problem: Cannot return TickableOctetBranchNode from method requiring IChildNode<OctetParentNode>
Solution: Implement explicit interface for base type:
  OctetParentNode IChildNode<OctetParentNode>.Parent => Parent;

3. Generic SubLatticeBranchNode Not Matching Pattern
Problem: SubLatticeBranchNode<TickableSpatialLattice> doesn't match SubLatticeBranchNode<ISpatialLattice>
Solution: Use the ISubLatticeBranch marker interface in pattern matching:
  case ISubLatticeBranch sublattice:
      return sublattice.GetSublattice().ResolveLeafFromOuterLattice(obj);

========================================
üìã Extension Checklist
========================================

When adding a new capability (like Tick):

‚òê Define interfaces for new behavior (ITickableSpatialNode, ITickableChildNode)
‚òê Create extended parent node class (TickableOctetParentNode)
‚òê Create extended branch node class (TickableOctetBranchNode)
‚òê Create extended venue leaf class (TickableVenueLeafNode)
‚òê Create extended sublattice branch class (TickableSubLatticeBranchNode)
‚òê Create root node declaring type family (TickableRootNode)
‚òê Create facade class inheriting SpatialLattice<TRoot> (TickableSpatialLattice)
‚òê Override CreateRoot() to return your custom root
‚òê Override CreateBranchNodeWithLeafs() in root node
‚òê Override CreateNewVenueNode() in root node
‚òê Implement explicit IChildNode<OctetParentNode> interfaces where needed
‚òê Write unit test for basic functionality
‚òê Write unit test for sublattice scenarios
‚òê Write performance benchmark

========================================
üöÄ Summary
========================================

This pattern lets you extend the lattice without modifying core code. The generic SpatialLattice<TRoot> and RootNode handle the infrastructure‚Äîyou just:

1. Define your interfaces
2. Extend the node types
3. Override factory methods
4. Inherit from SpatialLattice<YourRoot>

The result is a fully functional parallel hierarchy with all the lattice's spatial partitioning, thread-safety, and performance characteristics intact.

Key Lessons Learned from Tickable Implementation:
- Generic types with [ThreadStatic] are dangerous - use non-generic holder classes
- Pattern matching across generic instantiations requires marker interfaces
- Explicit interface implementations solve type compatibility issues
- Performance scales linearly to 200k+ objects with proper spatial partitioning

Good luck with your extension!